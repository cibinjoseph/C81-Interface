var tipuesearch = {"pages":[{"tags":"home","title":" C81 Interface ","loc":"index.html","text":"C81 Interface A collection of subroutines and functions in Fortran that help with parsing and creating C81 formatted airfoil tables. Developer Info Cibin Joseph Ph.D. student at IIT Madras, India."},{"tags":"","title":"demo3.f90 – C81 Interface","loc":"sourcefile/demo3.f90.html","text":"This file depends on sourcefile~~demo3.f90~~EfferentGraph sourcefile~demo3.f90 demo3.f90 sourcefile~libc81.f90 libC81.f90 sourcefile~demo3.f90->sourcefile~libc81.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs demo3 Source Code demo3.f90 Source Code ! This demo program reads the lift.csv and drag.csv files and writes it to ! an output file output.C81. Both files are in the Samples/ directory. program demo3 use libC81 implicit none integer , parameter :: rowsL = 25 integer , parameter :: colsL = 4 integer , parameter :: nMachL = 3 integer , parameter :: rowsD = 25 integer , parameter :: colsD = 4 integer , parameter :: nMachD = 3 integer :: i , j type ( C81_class ) :: C81 real , dimension ( rowsL , colsL ) :: LMat real , dimension ( rowsD , colsD ) :: DMat ! Read airfoil lift data from CSV file LMat = getTable ( 'Samples/lift.csv' , rowsL , colsL ) ! Read airfoil drag data from CSV file DMat = getTable ( 'Samples/drag.csv' , rowsD , colsD ) ! Allocate arrays allocate ( C81 % MaL ( nMachL )) allocate ( C81 % MaD ( nMachD )) allocate ( C81 % MaM ( nMachL )) allocate ( C81 % AL ( rowsL - 1 )) allocate ( C81 % AD ( rowsD - 1 )) allocate ( C81 % AM ( rowsL - 1 )) allocate ( C81 % CL ( rowsL - 1 , nMachL )) allocate ( C81 % CD ( rowsD - 1 , nMachD )) allocate ( C81 % CM ( rowsL - 1 , nMachL )) ! Specify airfoil name C81 % airfoilName = 'GA(W)-2' ! Copy values from read array to variables C81 % MaL = LMat ( 1 , 2 :) C81 % MaD = DMat ( 1 , 2 :) C81 % MaM = C81 % MaL C81 % AL = LMat ( 2 :, 1 ) C81 % AD = DMat ( 2 :, 1 ) C81 % AM = C81 % AL do j = 2 , colsL do i = 2 , rowsL C81 % CL ( i - 1 , j - 1 ) = LMat ( i , j ) enddo enddo do j = 2 , colsD do i = 2 , rowsD C81 % CD ( i - 1 , j - 1 ) = DMat ( i , j ) enddo enddo C81 % CM = C81 % CL ! Write airfoil data to C81 file call c81 % writefile ( 'Samples/output.C81' ) end program demo3"},{"tags":"","title":"demo2.f90 – C81 Interface","loc":"sourcefile/demo2.f90.html","text":"This file depends on sourcefile~~demo2.f90~~EfferentGraph sourcefile~demo2.f90 demo2.f90 sourcefile~libc81.f90 libC81.f90 sourcefile~demo2.f90->sourcefile~libc81.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs demo2 Source Code demo2.f90 Source Code ! This demo program reads the naca6403_Re20k.csv and writes it to ! an output file naca6403_Re20k.C81. Both files are in the Samples/ directory. program demo2 use libC81 implicit none integer , parameter :: rows = 19 integer , parameter :: cols = 4 integer , parameter :: nMach = cols - 1 integer :: i , j type ( C81_class ) :: C81 real , dimension ( rows , cols ) :: A ! Read airfoil data from CSV file A = getTable ( 'Samples/multiMain.csv' , rows , cols ) ! Allocate arrays allocate ( C81 % MaL ( nMach )) allocate ( C81 % MaD ( nMach )) allocate ( C81 % MaM ( nMach )) allocate ( C81 % AL ( rows - 1 )) allocate ( C81 % AD ( rows - 1 )) allocate ( C81 % AM ( rows - 1 )) allocate ( C81 % CL ( rows - 1 , nMach )) allocate ( C81 % CD ( rows - 1 , nMach )) allocate ( C81 % CM ( rows - 1 , nMach )) ! Specify airfoil name C81 % airfoilName = 'multiMain' ! Copy values from read array to variables C81 % MaL = A ( 1 , 2 :) C81 % MaD = C81 % MaL C81 % MaM = C81 % MaL C81 % AL = A ( 2 :, 1 ) C81 % AD = C81 % AL C81 % AM = C81 % AL do j = 2 , cols do i = 2 , rows C81 % CL ( i - 1 , j - 1 ) = A ( i , j ) enddo enddo C81 % CD = C81 % CL C81 % CM = C81 % CL ! Write airfoil data to C81 file call c81 % writefile ( 'Samples/multiMain.C81' ) end program demo2"},{"tags":"","title":"demo1.f90 – C81 Interface","loc":"sourcefile/demo1.f90.html","text":"This file depends on sourcefile~~demo1.f90~~EfferentGraph sourcefile~demo1.f90 demo1.f90 sourcefile~libc81.f90 libC81.f90 sourcefile~demo1.f90->sourcefile~libc81.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs demo1 Source Code demo1.f90 Source Code ! This demo program reads the C81 file sample1.C81 and writes the values read to ! an output file sampleOutput.C81. Both files are in the Samples/ directory. ! The working demo for the getTable() function, similar to dlmread() in Matlab, is also provided program demo1 use libC81 implicit none integer , parameter :: rows = 4 integer , parameter :: cols = 4 type ( C81_class ) :: C81 real , dimension ( 4 , 4 ) :: A integer :: i , j ! Read airfoil data from C81 file call C81 % readfile ( 'Samples/sample1.C81' ) print * , 'Airfoil data read SUCCESSFUL' print * ! Write airfoil data to C81 file call C81 % writefile ( 'Samples/sampleOutput.C81' ) print * , 'Airfoil data write SUCCESSFUL' print * ! Read tabular data from csv file to Fortran array ! Works similar to dlmread() from Matlab ! Useful for creating arrays from airfoil data in CSV format A = getTable ( 'Samples/sample1.csv' , rows , cols ) print * , 'Tabular data read SUCCESSFUL' print * do i = 1 , size ( A , 1 ) print * ,( A ( i , j ), j = 1 , size ( A , 2 )) enddo print * ! Find left and right indices from 1-d sorted array in which ! a queried value lies print * , A ( 1 ,:) print * , getInterval ( A ( 1 ,:), 0.15 ) print * , 'Binary search SUCCESSFUL' ! Return 2-d interpolated value from 2-d array print * print * , C81 % getCL ( - 1 4.5 , 0.425 ) print * , '2-d interpolation SUCCESSFUL' end program demo1"},{"tags":"","title":"libC81.f90 – C81 Interface","loc":"sourcefile/libc81.f90.html","text":"Files dependent on this one sourcefile~~libc81.f90~~AfferentGraph sourcefile~libc81.f90 libC81.f90 sourcefile~demo3.f90 demo3.f90 sourcefile~demo3.f90->sourcefile~libc81.f90 sourcefile~demo2.f90 demo2.f90 sourcefile~demo2.f90->sourcefile~libc81.f90 sourcefile~demo1.f90 demo1.f90 sourcefile~demo1.f90->sourcefile~libc81.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules libC81 Source Code libC81.f90 Source Code module libC81 implicit none type C81_class !! Base class for C81 performance data character ( len = 30 ) :: airfoilName integer :: ML !! No. of lift coefficient machs integer :: NL !! No. of lift coefficient alphas integer :: MD !! No. of drag coefficient machs integer :: ND !! No. of drag coefficient alphas integer :: MM !! No. of moment coefficient machs integer :: NM !! No. of moment coefficient alphas real , allocatable , dimension (:) :: MaL !! Machs for lift real , allocatable , dimension (:) :: MaD !! Machs for drag real , allocatable , dimension (:) :: MaM !! Machs for moment real , allocatable , dimension (:) :: AL !! Alphas for lift real , allocatable , dimension (:) :: AD !! Alphas for drag real , allocatable , dimension (:) :: AM !! Alphas for moment real , allocatable , dimension (:,:) :: CL !! Lift coefficient real , allocatable , dimension (:,:) :: CD !! Drag coefficient real , allocatable , dimension (:,:) :: CM !! Moment coefficient contains procedure :: writefile procedure :: readfile procedure :: getCL procedure :: getCD procedure :: getCM end type C81_class contains subroutine writefile ( this , C81filename ) !! Writes C81 class data to C81 file class ( C81_class ) :: this character ( len =* ), intent ( in ) :: C81filename integer :: i , j logical :: fileExists character ( len = 10 ) :: formatChar character ( len = 1 ) :: overwriteOption inquire ( file = C81filename , exist = fileExists ) if ( fileExists ) then print * , 'File ' // trim ( C81filename ) // ' already exists!' write ( * , '(A)' , advance = 'no' ) ' Okay to overwrite (y/n)? ' read ( * , * ) overwriteOption print * if (( overwriteOption . ne . 'y' ) . and . ( overwriteOption . ne . 'Y' )) stop endif open ( unit = 10 , file = C81filename , action = 'write' ) this % ML = size ( this % MaL , 1 ) this % MD = size ( this % MaD , 1 ) this % MM = size ( this % MaM , 1 ) this % NL = size ( this % AL , 1 ) this % ND = size ( this % AD , 1 ) this % NM = size ( this % AM , 1 ) write ( 10 , 100 ) this % airfoilName , this % ML , this % NL , this % MD , this % ND , this % MM , this % NM ! Lift write ( 10 , 101 ) ( this % MaL ( i ), i = 1 , min ( 9 , this % ML )) if ( this % ML > 9 ) then write ( formatChar , '(A4,I1,A5)' ) '(7X,' , this % ML - 9 , 'F7.3)' write ( 10 , formatChar ) ( this % MaL ( i ), i = 10 , this % ML ) endif do i = 1 , this % NL write ( 10 , 102 ) this % AL ( i ), ( this % CL ( i , j ), j = 1 , min ( 9 , this % ML )) if ( this % ML > 9 ) write ( 10 , formatChar ) ( this % CL ( i , j ), j = 10 , this % ML ) enddo ! Drag write ( 10 , 101 ) ( this % MaD ( i ), i = 1 , min ( 9 , this % MD )) if ( this % MD > 9 ) then write ( formatChar , '(A4,I1,A5)' ) '(7X,' , this % MD - 9 , 'F7.3)' write ( 10 , formatChar ) ( this % MaD ( i ), i = 10 , this % MD ) endif do i = 1 , this % ND write ( 10 , 102 ) this % AD ( i ), ( this % CD ( i , j ), j = 1 , min ( 9 , this % MD )) if ( this % MD > 9 ) write ( 10 , formatChar ) ( this % CD ( i , j ), j = 10 , this % MD ) enddo ! Moment write ( 10 , 101 ) ( this % MaM ( i ), i = 1 , min ( 9 , this % MM )) if ( this % MM > 9 ) then write ( formatChar , '(A4,I1,A5)' ) '(7X,' , this % MM - 9 , 'F7.3)' write ( 10 , formatChar ) ( this % MaM ( i ), i = 10 , this % MM ) endif do i = 1 , this % NM write ( 10 , 102 ) this % AM ( i ), ( this % CM ( i , j ), j = 1 , min ( 9 , this % MM )) if ( this % MM > 9 ) write ( 10 , formatChar ) ( this % CM ( i , j ), j = 10 , this % MM ) enddo close ( 10 ) 100 format ( A30 , 6 I0 . 2 ) 101 format ( 7 X , 9 F7 . 3 ) 102 format ( F7 . 2 , 9 F7 . 3 ) end subroutine writefile subroutine readfile ( this , C81filename ) !! Reads from C81 file to C81 class class ( C81_class ) :: this character ( len =* ), intent ( in ) :: C81filename integer :: i , j integer :: stat character ( len = 10 ) :: formatChar open ( unit = 10 , file = C81filename , status = 'old' , action = 'read' , iostat = stat ) if ( stat > 0 ) error stop 'ERROR: File not found' read ( 10 , 100 ) this % airfoilName , this % ML , this % NL , this % MD , this % ND , this % MM , this % NM allocate ( this % MaL ( this % ML )) allocate ( this % MaD ( this % MD )) allocate ( this % MaM ( this % MM )) allocate ( this % AL ( this % NL )) allocate ( this % AD ( this % ND )) allocate ( this % AM ( this % NM )) allocate ( this % CL ( this % NL , this % ML )) allocate ( this % CD ( this % ND , this % MD )) allocate ( this % CM ( this % NM , this % MM )) ! Lift read ( 10 , 101 ) ( this % MaL ( i ), i = 1 , min ( 9 , this % ML )) if ( this % ML > 9 ) then write ( formatChar , '(A4,I1,A5)' ) '(7X,' , this % ML - 9 , 'F7.0)' read ( 10 , formatChar ) ( this % MaL ( i ), i = 10 , this % ML ) endif do i = 1 , this % NL read ( 10 , 102 ) this % AL ( i ), ( this % CL ( i , j ), j = 1 , min ( 9 , this % ML )) if ( this % ML > 9 ) read ( 10 , formatChar ) ( this % CL ( i , j ), j = 10 , this % ML ) enddo ! Drag read ( 10 , 101 ) ( this % MaD ( i ), i = 1 , min ( 9 , this % MD )) if ( this % MD > 9 ) then write ( formatChar , '(A4,I1,A5)' ) '(7X,' , this % MD - 9 , 'F7.0)' read ( 10 , formatChar ) ( this % MaD ( i ), i = 10 , this % MD ) endif do i = 1 , this % ND read ( 10 , 102 ) this % AD ( i ), ( this % CD ( i , j ), j = 1 , min ( 9 , this % MD )) if ( this % MD > 9 ) read ( 10 , formatChar ) ( this % CD ( i , j ), j = 10 , this % MD ) enddo ! Moment read ( 10 , 101 ) ( this % MaM ( i ), i = 1 , min ( 9 , this % MM )) if ( this % MM > 9 ) then write ( formatChar , '(A4,I1,A5)' ) '(7X,' , this % MM - 9 , 'F7.0)' read ( 10 , formatChar ) ( this % MaM ( i ), i = 10 , this % MM ) endif do i = 1 , this % NM read ( 10 , 102 ) this % AM ( i ), ( this % CM ( i , j ), j = 1 , min ( 9 , this % MM )) if ( this % MM > 9 ) read ( 10 , formatChar ) ( this % CM ( i , j ), j = 10 , this % MM ) enddo close ( 10 ) 100 format ( A30 , 6 I2 ) 101 format ( 7 X , 9 F7 . 0 ) 102 format ( 10 F7 . 0 ) end subroutine readfile function getCL ( this , alphaQuery , machQuery ) !! Returns value of 2-d linear interpolated CL !! for a given alphaQuery and machQuery values class ( C81_class ) :: this real , intent ( in ) :: alphaQuery , machQuery real :: getCL integer , dimension ( 2 ) :: alphaIndx , machIndx alphaIndx = getInterval ( this % AL , alphaQuery ) machIndx = getInterval ( this % MaL , machQuery ) getCL = getBilinearInterp ( alphaQuery , machQuery , & ( / this % AL ( alphaIndx ( 1 )), this % AL ( alphaIndx ( 2 )) / ), & ( / this % MaL ( machIndx ( 1 )), this % MaL ( machIndx ( 2 )) / ), & this % CL ( alphaIndx ( 1 ), machIndx ( 1 )), & this % CL ( alphaIndx ( 1 ), machIndx ( 2 )), & this % CL ( alphaIndx ( 2 ), machIndx ( 1 )), & this % CL ( alphaIndx ( 2 ), machIndx ( 2 ))) end function getCL function getCD ( this , alphaQuery , machQuery ) !! Returns value of 2-d linearly interpolated CD !! for given alphaQuery and machQuery values class ( C81_class ) :: this real , intent ( in ) :: alphaQuery , machQuery real :: getCD integer , dimension ( 2 ) :: alphaIndx , machIndx alphaIndx = getInterval ( this % AL , alphaQuery ) machIndx = getInterval ( this % MaL , machQuery ) getCD = getBilinearInterp ( alphaQuery , machQuery , & ( / this % AD ( alphaIndx ( 1 )), this % AD ( alphaIndx ( 2 )) / ), & ( / this % MaD ( machIndx ( 1 )), this % MaD ( machIndx ( 2 )) / ), & this % CD ( alphaIndx ( 1 ), machIndx ( 1 )), & this % CD ( alphaIndx ( 1 ), machIndx ( 2 )), & this % CD ( alphaIndx ( 2 ), machIndx ( 1 )), & this % CD ( alphaIndx ( 2 ), machIndx ( 2 ))) end function getCD function getCM ( this , alphaQuery , machQuery ) !! Returns value of 2-d linearly interpolated CM !! for given alphaQuery and machQuery values class ( C81_class ) :: this real , intent ( in ) :: alphaQuery , machQuery real :: getCM integer , dimension ( 2 ) :: alphaIndx , machIndx alphaIndx = getInterval ( this % AL , alphaQuery ) machIndx = getInterval ( this % MaL , machQuery ) getCM = getBilinearInterp ( alphaQuery , machQuery , & ( / this % AM ( alphaIndx ( 1 )), this % AM ( alphaIndx ( 2 )) / ), & ( / this % MaM ( machIndx ( 1 )), this % MaM ( machIndx ( 2 )) / ), & this % CM ( alphaIndx ( 1 ), machIndx ( 1 )), & this % CM ( alphaIndx ( 1 ), machIndx ( 2 )), & this % CM ( alphaIndx ( 2 ), machIndx ( 1 )), & this % CM ( alphaIndx ( 2 ), machIndx ( 2 ))) end function getCM function getInterval ( A , x ) result ( indx ) !! Returns upper and lower indices of a 1-d sorted array !! using binary search in which a search value lies real , intent ( in ), dimension (:) :: A real , intent ( in ) :: x integer , dimension ( 2 ) :: indx ! Left and right indices integer :: n , i n = size ( A , 1 ) indx ( 1 ) = 1 indx ( 2 ) = n ! Binary search algorithm do while (( indx ( 1 ) . ne . indx ( 2 )) . and . ( indx ( 2 ) . ne . ( indx ( 1 ) + 1 ))) i = floor (( indx ( 1 ) + indx ( 2 )) * 0.5 ) if ( x < A ( i )) then indx ( 2 ) = i elseif ( x > A ( i )) then indx ( 1 ) = i else indx ( 1 ) = i indx ( 2 ) = i endif enddo ! Check end cases if ( abs ( A ( indx ( 1 )) - x ) . le . epsilon ( 1. )) then indx ( 2 ) = indx ( 1 ) elseif ( abs ( A ( indx ( 2 )) - x ) . le . epsilon ( 1. )) then indx ( 1 ) = indx ( 2 ) endif end function getInterval function getBilinearInterp ( x , y , xvec , yvec , f11 , f12 , f21 , f22 ) !! Returns bilinearly interpolated values at (x,y) real , intent ( in ) :: x !! Queried x real , intent ( in ) :: y !! Queried y real , intent ( in ), dimension ( 2 ) :: xvec real , intent ( in ), dimension ( 2 ) :: yvec real , intent ( in ) :: f11 , f12 , f21 , f22 real :: getBilinearInterp real , dimension ( 2 , 2 ) :: fMat fMat ( 1 ,:) = ( / f11 , f12 / ) fMat ( 2 ,:) = ( / f21 , f22 / ) getBilinearInterp = dot_product (( / xvec ( 2 ) - x , x - xvec ( 1 ) / ), matmul ( fMat ,( / yvec ( 2 ) - y , y - yvec ( 1 ) / ))) getBilinearInterp = getBilinearInterp / ( xvec ( 2 ) - xvec ( 1 )) / ( yvec ( 2 ) - yvec ( 1 )) end function getBilinearInterp function getTable ( filename , rows , cols ) !! Returns data from csv formatted file character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: rows !! No. of rows integer , intent ( in ) :: cols !! No. of columns integer :: i , j integer :: stat real , dimension ( rows , cols ) :: getTable open ( unit = 10 , file = filename , status = 'old' , action = 'read' , iostat = stat ) if ( stat > 0 ) error stop 'ERROR: File not found' do i = 1 , rows read ( 10 , * ) ( getTable ( i , j ), j = 1 , cols ) enddo close ( 10 ) end function getTable end module libC81"},{"tags":"","title":"C81_class – C81 Interface ","loc":"type/c81_class.html","text":"type, public :: C81_class Base class for C81 performance data Contents Variables airfoilName ML NL MD ND MM NM MaL MaD MaM AL AD AM CL CD CM Type-Bound Procedures writefile readfile getCL getCD getCM Source Code C81_class Components Type Visibility Attributes Name Initial character(len=30), public :: airfoilName integer, public :: ML No. of lift coefficient machs integer, public :: NL No. of lift coefficient alphas integer, public :: MD No. of drag coefficient machs integer, public :: ND No. of drag coefficient alphas integer, public :: MM No. of moment coefficient machs integer, public :: NM No. of moment coefficient alphas real, public, allocatable, dimension(:) :: MaL Machs for lift real, public, allocatable, dimension(:) :: MaD Machs for drag real, public, allocatable, dimension(:) :: MaM Machs for moment real, public, allocatable, dimension(:) :: AL Alphas for lift real, public, allocatable, dimension(:) :: AD Alphas for drag real, public, allocatable, dimension(:) :: AM Alphas for moment real, public, allocatable, dimension(:,:) :: CL Lift coefficient real, public, allocatable, dimension(:,:) :: CD Drag coefficient real, public, allocatable, dimension(:,:) :: CM Moment coefficient Type-Bound Procedures procedure, public :: writefile public subroutine writefile (this, C81filename) Writes C81 class data to C81 file Arguments Type Intent Optional Attributes Name class( C81_class ) :: this character(len=*), intent(in) :: C81filename procedure, public :: readfile public subroutine readfile (this, C81filename) Reads from C81 file to C81 class Arguments Type Intent Optional Attributes Name class( C81_class ) :: this character(len=*), intent(in) :: C81filename procedure, public :: getCL public function getCL (this, alphaQuery, machQuery) Returns value of 2-d linear interpolated CL\n for a given alphaQuery and machQuery values Arguments Type Intent Optional Attributes Name class( C81_class ) :: this real, intent(in) :: alphaQuery real, intent(in) :: machQuery Return Value real procedure, public :: getCD public function getCD (this, alphaQuery, machQuery) Returns value of 2-d linearly interpolated CD\n for given alphaQuery and machQuery values Arguments Type Intent Optional Attributes Name class( C81_class ) :: this real, intent(in) :: alphaQuery real, intent(in) :: machQuery Return Value real procedure, public :: getCM public function getCM (this, alphaQuery, machQuery) Returns value of 2-d linearly interpolated CM\n for given alphaQuery and machQuery values Arguments Type Intent Optional Attributes Name class( C81_class ) :: this real, intent(in) :: alphaQuery real, intent(in) :: machQuery Return Value real Source Code type C81_class !! Base class for C81 performance data character ( len = 30 ) :: airfoilName integer :: ML !! No. of lift coefficient machs integer :: NL !! No. of lift coefficient alphas integer :: MD !! No. of drag coefficient machs integer :: ND !! No. of drag coefficient alphas integer :: MM !! No. of moment coefficient machs integer :: NM !! No. of moment coefficient alphas real , allocatable , dimension (:) :: MaL !! Machs for lift real , allocatable , dimension (:) :: MaD !! Machs for drag real , allocatable , dimension (:) :: MaM !! Machs for moment real , allocatable , dimension (:) :: AL !! Alphas for lift real , allocatable , dimension (:) :: AD !! Alphas for drag real , allocatable , dimension (:) :: AM !! Alphas for moment real , allocatable , dimension (:,:) :: CL !! Lift coefficient real , allocatable , dimension (:,:) :: CD !! Drag coefficient real , allocatable , dimension (:,:) :: CM !! Moment coefficient contains procedure :: writefile procedure :: readfile procedure :: getCL procedure :: getCD procedure :: getCM end type C81_class"},{"tags":"","title":"getCL – C81 Interface","loc":"proc/getcl.html","text":"public function getCL(this, alphaQuery, machQuery) Returns value of 2-d linear interpolated CL\n for a given alphaQuery and machQuery values Arguments Type Intent Optional Attributes Name class( C81_class ) :: this real, intent(in) :: alphaQuery real, intent(in) :: machQuery Return Value real Calls proc~~getcl~~CallsGraph proc~getcl getCL proc~getinterval getInterval proc~getcl->proc~getinterval proc~getbilinearinterp getBilinearInterp proc~getcl->proc~getbilinearinterp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code getCL Source Code function getCL ( this , alphaQuery , machQuery ) !! Returns value of 2-d linear interpolated CL !! for a given alphaQuery and machQuery values class ( C81_class ) :: this real , intent ( in ) :: alphaQuery , machQuery real :: getCL integer , dimension ( 2 ) :: alphaIndx , machIndx alphaIndx = getInterval ( this % AL , alphaQuery ) machIndx = getInterval ( this % MaL , machQuery ) getCL = getBilinearInterp ( alphaQuery , machQuery , & ( / this % AL ( alphaIndx ( 1 )), this % AL ( alphaIndx ( 2 )) / ), & ( / this % MaL ( machIndx ( 1 )), this % MaL ( machIndx ( 2 )) / ), & this % CL ( alphaIndx ( 1 ), machIndx ( 1 )), & this % CL ( alphaIndx ( 1 ), machIndx ( 2 )), & this % CL ( alphaIndx ( 2 ), machIndx ( 1 )), & this % CL ( alphaIndx ( 2 ), machIndx ( 2 ))) end function getCL"},{"tags":"","title":"getCD – C81 Interface","loc":"proc/getcd.html","text":"public function getCD(this, alphaQuery, machQuery) Returns value of 2-d linearly interpolated CD\n for given alphaQuery and machQuery values Arguments Type Intent Optional Attributes Name class( C81_class ) :: this real, intent(in) :: alphaQuery real, intent(in) :: machQuery Return Value real Calls proc~~getcd~~CallsGraph proc~getcd getCD proc~getinterval getInterval proc~getcd->proc~getinterval proc~getbilinearinterp getBilinearInterp proc~getcd->proc~getbilinearinterp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code getCD Source Code function getCD ( this , alphaQuery , machQuery ) !! Returns value of 2-d linearly interpolated CD !! for given alphaQuery and machQuery values class ( C81_class ) :: this real , intent ( in ) :: alphaQuery , machQuery real :: getCD integer , dimension ( 2 ) :: alphaIndx , machIndx alphaIndx = getInterval ( this % AL , alphaQuery ) machIndx = getInterval ( this % MaL , machQuery ) getCD = getBilinearInterp ( alphaQuery , machQuery , & ( / this % AD ( alphaIndx ( 1 )), this % AD ( alphaIndx ( 2 )) / ), & ( / this % MaD ( machIndx ( 1 )), this % MaD ( machIndx ( 2 )) / ), & this % CD ( alphaIndx ( 1 ), machIndx ( 1 )), & this % CD ( alphaIndx ( 1 ), machIndx ( 2 )), & this % CD ( alphaIndx ( 2 ), machIndx ( 1 )), & this % CD ( alphaIndx ( 2 ), machIndx ( 2 ))) end function getCD"},{"tags":"","title":"getCM – C81 Interface","loc":"proc/getcm.html","text":"public function getCM(this, alphaQuery, machQuery) Returns value of 2-d linearly interpolated CM\n for given alphaQuery and machQuery values Arguments Type Intent Optional Attributes Name class( C81_class ) :: this real, intent(in) :: alphaQuery real, intent(in) :: machQuery Return Value real Calls proc~~getcm~~CallsGraph proc~getcm getCM proc~getinterval getInterval proc~getcm->proc~getinterval proc~getbilinearinterp getBilinearInterp proc~getcm->proc~getbilinearinterp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code getCM Source Code function getCM ( this , alphaQuery , machQuery ) !! Returns value of 2-d linearly interpolated CM !! for given alphaQuery and machQuery values class ( C81_class ) :: this real , intent ( in ) :: alphaQuery , machQuery real :: getCM integer , dimension ( 2 ) :: alphaIndx , machIndx alphaIndx = getInterval ( this % AL , alphaQuery ) machIndx = getInterval ( this % MaL , machQuery ) getCM = getBilinearInterp ( alphaQuery , machQuery , & ( / this % AM ( alphaIndx ( 1 )), this % AM ( alphaIndx ( 2 )) / ), & ( / this % MaM ( machIndx ( 1 )), this % MaM ( machIndx ( 2 )) / ), & this % CM ( alphaIndx ( 1 ), machIndx ( 1 )), & this % CM ( alphaIndx ( 1 ), machIndx ( 2 )), & this % CM ( alphaIndx ( 2 ), machIndx ( 1 )), & this % CM ( alphaIndx ( 2 ), machIndx ( 2 ))) end function getCM"},{"tags":"","title":"getInterval – C81 Interface","loc":"proc/getinterval.html","text":"public function getInterval(A, x) result(indx) Returns upper and lower indices of a 1-d sorted array \n using binary search in which a search value lies Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: A real, intent(in) :: x Return Value integer,\n  dimension(2) Called by proc~~getinterval~~CalledByGraph proc~getinterval getInterval proc~getcm getCM proc~getcm->proc~getinterval proc~getcl getCL proc~getcl->proc~getinterval program~demo1 demo1 program~demo1->proc~getinterval proc~getcd getCD proc~getcd->proc~getinterval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code getInterval Source Code function getInterval ( A , x ) result ( indx ) !! Returns upper and lower indices of a 1-d sorted array !! using binary search in which a search value lies real , intent ( in ), dimension (:) :: A real , intent ( in ) :: x integer , dimension ( 2 ) :: indx ! Left and right indices integer :: n , i n = size ( A , 1 ) indx ( 1 ) = 1 indx ( 2 ) = n ! Binary search algorithm do while (( indx ( 1 ) . ne . indx ( 2 )) . and . ( indx ( 2 ) . ne . ( indx ( 1 ) + 1 ))) i = floor (( indx ( 1 ) + indx ( 2 )) * 0.5 ) if ( x < A ( i )) then indx ( 2 ) = i elseif ( x > A ( i )) then indx ( 1 ) = i else indx ( 1 ) = i indx ( 2 ) = i endif enddo ! Check end cases if ( abs ( A ( indx ( 1 )) - x ) . le . epsilon ( 1. )) then indx ( 2 ) = indx ( 1 ) elseif ( abs ( A ( indx ( 2 )) - x ) . le . epsilon ( 1. )) then indx ( 1 ) = indx ( 2 ) endif end function getInterval"},{"tags":"","title":"getBilinearInterp – C81 Interface","loc":"proc/getbilinearinterp.html","text":"public function getBilinearInterp(x, y, xvec, yvec, f11, f12, f21, f22) Returns bilinearly interpolated values at (x,y) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Queried x real, intent(in) :: y Queried y real, intent(in), dimension(2) :: xvec real, intent(in), dimension(2) :: yvec real, intent(in) :: f11 real, intent(in) :: f12 real, intent(in) :: f21 real, intent(in) :: f22 Return Value real Called by proc~~getbilinearinterp~~CalledByGraph proc~getbilinearinterp getBilinearInterp proc~getcm getCM proc~getcm->proc~getbilinearinterp proc~getcl getCL proc~getcl->proc~getbilinearinterp proc~getcd getCD proc~getcd->proc~getbilinearinterp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code getBilinearInterp Source Code function getBilinearInterp ( x , y , xvec , yvec , f11 , f12 , f21 , f22 ) !! Returns bilinearly interpolated values at (x,y) real , intent ( in ) :: x !! Queried x real , intent ( in ) :: y !! Queried y real , intent ( in ), dimension ( 2 ) :: xvec real , intent ( in ), dimension ( 2 ) :: yvec real , intent ( in ) :: f11 , f12 , f21 , f22 real :: getBilinearInterp real , dimension ( 2 , 2 ) :: fMat fMat ( 1 ,:) = ( / f11 , f12 / ) fMat ( 2 ,:) = ( / f21 , f22 / ) getBilinearInterp = dot_product (( / xvec ( 2 ) - x , x - xvec ( 1 ) / ), matmul ( fMat ,( / yvec ( 2 ) - y , y - yvec ( 1 ) / ))) getBilinearInterp = getBilinearInterp / ( xvec ( 2 ) - xvec ( 1 )) / ( yvec ( 2 ) - yvec ( 1 )) end function getBilinearInterp"},{"tags":"","title":"getTable – C81 Interface","loc":"proc/gettable.html","text":"public function getTable(filename, rows, cols) Returns data from csv formatted file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer, intent(in) :: rows No. of rows integer, intent(in) :: cols No. of columns Return Value real,\n  dimension(rows,cols) Called by proc~~gettable~~CalledByGraph proc~gettable getTable program~demo1 demo1 program~demo1->proc~gettable program~demo2 demo2 program~demo2->proc~gettable program~demo3 demo3 program~demo3->proc~gettable Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code getTable Source Code function getTable ( filename , rows , cols ) !! Returns data from csv formatted file character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: rows !! No. of rows integer , intent ( in ) :: cols !! No. of columns integer :: i , j integer :: stat real , dimension ( rows , cols ) :: getTable open ( unit = 10 , file = filename , status = 'old' , action = 'read' , iostat = stat ) if ( stat > 0 ) error stop 'ERROR: File not found' do i = 1 , rows read ( 10 , * ) ( getTable ( i , j ), j = 1 , cols ) enddo close ( 10 ) end function getTable"},{"tags":"","title":"writefile – C81 Interface","loc":"proc/writefile.html","text":"public subroutine writefile(this, C81filename) Writes C81 class data to C81 file Arguments Type Intent Optional Attributes Name class( C81_class ) :: this character(len=*), intent(in) :: C81filename Contents Source Code writefile Source Code subroutine writefile ( this , C81filename ) !! Writes C81 class data to C81 file class ( C81_class ) :: this character ( len =* ), intent ( in ) :: C81filename integer :: i , j logical :: fileExists character ( len = 10 ) :: formatChar character ( len = 1 ) :: overwriteOption inquire ( file = C81filename , exist = fileExists ) if ( fileExists ) then print * , 'File ' // trim ( C81filename ) // ' already exists!' write ( * , '(A)' , advance = 'no' ) ' Okay to overwrite (y/n)? ' read ( * , * ) overwriteOption print * if (( overwriteOption . ne . 'y' ) . and . ( overwriteOption . ne . 'Y' )) stop endif open ( unit = 10 , file = C81filename , action = 'write' ) this % ML = size ( this % MaL , 1 ) this % MD = size ( this % MaD , 1 ) this % MM = size ( this % MaM , 1 ) this % NL = size ( this % AL , 1 ) this % ND = size ( this % AD , 1 ) this % NM = size ( this % AM , 1 ) write ( 10 , 100 ) this % airfoilName , this % ML , this % NL , this % MD , this % ND , this % MM , this % NM ! Lift write ( 10 , 101 ) ( this % MaL ( i ), i = 1 , min ( 9 , this % ML )) if ( this % ML > 9 ) then write ( formatChar , '(A4,I1,A5)' ) '(7X,' , this % ML - 9 , 'F7.3)' write ( 10 , formatChar ) ( this % MaL ( i ), i = 10 , this % ML ) endif do i = 1 , this % NL write ( 10 , 102 ) this % AL ( i ), ( this % CL ( i , j ), j = 1 , min ( 9 , this % ML )) if ( this % ML > 9 ) write ( 10 , formatChar ) ( this % CL ( i , j ), j = 10 , this % ML ) enddo ! Drag write ( 10 , 101 ) ( this % MaD ( i ), i = 1 , min ( 9 , this % MD )) if ( this % MD > 9 ) then write ( formatChar , '(A4,I1,A5)' ) '(7X,' , this % MD - 9 , 'F7.3)' write ( 10 , formatChar ) ( this % MaD ( i ), i = 10 , this % MD ) endif do i = 1 , this % ND write ( 10 , 102 ) this % AD ( i ), ( this % CD ( i , j ), j = 1 , min ( 9 , this % MD )) if ( this % MD > 9 ) write ( 10 , formatChar ) ( this % CD ( i , j ), j = 10 , this % MD ) enddo ! Moment write ( 10 , 101 ) ( this % MaM ( i ), i = 1 , min ( 9 , this % MM )) if ( this % MM > 9 ) then write ( formatChar , '(A4,I1,A5)' ) '(7X,' , this % MM - 9 , 'F7.3)' write ( 10 , formatChar ) ( this % MaM ( i ), i = 10 , this % MM ) endif do i = 1 , this % NM write ( 10 , 102 ) this % AM ( i ), ( this % CM ( i , j ), j = 1 , min ( 9 , this % MM )) if ( this % MM > 9 ) write ( 10 , formatChar ) ( this % CM ( i , j ), j = 10 , this % MM ) enddo close ( 10 ) 100 format ( A30 , 6 I0 . 2 ) 101 format ( 7 X , 9 F7 . 3 ) 102 format ( F7 . 2 , 9 F7 . 3 ) end subroutine writefile"},{"tags":"","title":"readfile – C81 Interface","loc":"proc/readfile.html","text":"public subroutine readfile(this, C81filename) Reads from C81 file to C81 class Arguments Type Intent Optional Attributes Name class( C81_class ) :: this character(len=*), intent(in) :: C81filename Contents Source Code readfile Source Code subroutine readfile ( this , C81filename ) !! Reads from C81 file to C81 class class ( C81_class ) :: this character ( len =* ), intent ( in ) :: C81filename integer :: i , j integer :: stat character ( len = 10 ) :: formatChar open ( unit = 10 , file = C81filename , status = 'old' , action = 'read' , iostat = stat ) if ( stat > 0 ) error stop 'ERROR: File not found' read ( 10 , 100 ) this % airfoilName , this % ML , this % NL , this % MD , this % ND , this % MM , this % NM allocate ( this % MaL ( this % ML )) allocate ( this % MaD ( this % MD )) allocate ( this % MaM ( this % MM )) allocate ( this % AL ( this % NL )) allocate ( this % AD ( this % ND )) allocate ( this % AM ( this % NM )) allocate ( this % CL ( this % NL , this % ML )) allocate ( this % CD ( this % ND , this % MD )) allocate ( this % CM ( this % NM , this % MM )) ! Lift read ( 10 , 101 ) ( this % MaL ( i ), i = 1 , min ( 9 , this % ML )) if ( this % ML > 9 ) then write ( formatChar , '(A4,I1,A5)' ) '(7X,' , this % ML - 9 , 'F7.0)' read ( 10 , formatChar ) ( this % MaL ( i ), i = 10 , this % ML ) endif do i = 1 , this % NL read ( 10 , 102 ) this % AL ( i ), ( this % CL ( i , j ), j = 1 , min ( 9 , this % ML )) if ( this % ML > 9 ) read ( 10 , formatChar ) ( this % CL ( i , j ), j = 10 , this % ML ) enddo ! Drag read ( 10 , 101 ) ( this % MaD ( i ), i = 1 , min ( 9 , this % MD )) if ( this % MD > 9 ) then write ( formatChar , '(A4,I1,A5)' ) '(7X,' , this % MD - 9 , 'F7.0)' read ( 10 , formatChar ) ( this % MaD ( i ), i = 10 , this % MD ) endif do i = 1 , this % ND read ( 10 , 102 ) this % AD ( i ), ( this % CD ( i , j ), j = 1 , min ( 9 , this % MD )) if ( this % MD > 9 ) read ( 10 , formatChar ) ( this % CD ( i , j ), j = 10 , this % MD ) enddo ! Moment read ( 10 , 101 ) ( this % MaM ( i ), i = 1 , min ( 9 , this % MM )) if ( this % MM > 9 ) then write ( formatChar , '(A4,I1,A5)' ) '(7X,' , this % MM - 9 , 'F7.0)' read ( 10 , formatChar ) ( this % MaM ( i ), i = 10 , this % MM ) endif do i = 1 , this % NM read ( 10 , 102 ) this % AM ( i ), ( this % CM ( i , j ), j = 1 , min ( 9 , this % MM )) if ( this % MM > 9 ) read ( 10 , formatChar ) ( this % CM ( i , j ), j = 10 , this % MM ) enddo close ( 10 ) 100 format ( A30 , 6 I2 ) 101 format ( 7 X , 9 F7 . 0 ) 102 format ( 10 F7 . 0 ) end subroutine readfile"},{"tags":"","title":"libC81 – C81 Interface","loc":"module/libc81.html","text":"Used by module~~libc81~~UsedByGraph module~libc81 libC81 program~demo1 demo1 program~demo1->module~libc81 program~demo2 demo2 program~demo2->module~libc81 program~demo3 demo3 program~demo3->module~libc81 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types C81_class Functions getCL getCD getCM getInterval getBilinearInterp getTable Subroutines writefile readfile Derived Types type, public :: C81_class Base class for C81 performance data Components Type Visibility Attributes Name Initial character(len=30), public :: airfoilName integer, public :: ML No. of lift coefficient machs integer, public :: NL No. of lift coefficient alphas integer, public :: MD No. of drag coefficient machs integer, public :: ND No. of drag coefficient alphas integer, public :: MM No. of moment coefficient machs integer, public :: NM No. of moment coefficient alphas real, public, allocatable, dimension(:) :: MaL Machs for lift real, public, allocatable, dimension(:) :: MaD Machs for drag real, public, allocatable, dimension(:) :: MaM Machs for moment real, public, allocatable, dimension(:) :: AL Alphas for lift real, public, allocatable, dimension(:) :: AD Alphas for drag real, public, allocatable, dimension(:) :: AM Alphas for moment real, public, allocatable, dimension(:,:) :: CL Lift coefficient real, public, allocatable, dimension(:,:) :: CD Drag coefficient real, public, allocatable, dimension(:,:) :: CM Moment coefficient Type-Bound Procedures procedure, public :: writefile procedure, public :: readfile procedure, public :: getCL procedure, public :: getCD procedure, public :: getCM Functions public function getCL (this, alphaQuery, machQuery) Returns value of 2-d linear interpolated CL\n for a given alphaQuery and machQuery values Arguments Type Intent Optional Attributes Name class( C81_class ) :: this real, intent(in) :: alphaQuery real, intent(in) :: machQuery Return Value real public function getCD (this, alphaQuery, machQuery) Returns value of 2-d linearly interpolated CD\n for given alphaQuery and machQuery values Arguments Type Intent Optional Attributes Name class( C81_class ) :: this real, intent(in) :: alphaQuery real, intent(in) :: machQuery Return Value real public function getCM (this, alphaQuery, machQuery) Returns value of 2-d linearly interpolated CM\n for given alphaQuery and machQuery values Arguments Type Intent Optional Attributes Name class( C81_class ) :: this real, intent(in) :: alphaQuery real, intent(in) :: machQuery Return Value real public function getInterval (A, x) result(indx) Returns upper and lower indices of a 1-d sorted array \n using binary search in which a search value lies Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: A real, intent(in) :: x Return Value integer,\n  dimension(2) public function getBilinearInterp (x, y, xvec, yvec, f11, f12, f21, f22) Returns bilinearly interpolated values at (x,y) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Queried x real, intent(in) :: y Queried y real, intent(in), dimension(2) :: xvec real, intent(in), dimension(2) :: yvec real, intent(in) :: f11 real, intent(in) :: f12 real, intent(in) :: f21 real, intent(in) :: f22 Return Value real public function getTable (filename, rows, cols) Returns data from csv formatted file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer, intent(in) :: rows No. of rows integer, intent(in) :: cols No. of columns Return Value real,\n  dimension(rows,cols) Subroutines public subroutine writefile (this, C81filename) Writes C81 class data to C81 file Arguments Type Intent Optional Attributes Name class( C81_class ) :: this character(len=*), intent(in) :: C81filename public subroutine readfile (this, C81filename) Reads from C81 file to C81 class Arguments Type Intent Optional Attributes Name class( C81_class ) :: this character(len=*), intent(in) :: C81filename"},{"tags":"","title":"demo3 – C81 Interface","loc":"program/demo3.html","text":"Uses libC81 program~~demo3~~UsesGraph program~demo3 demo3 module~libc81 libC81 program~demo3->module~libc81 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~demo3~~CallsGraph program~demo3 demo3 proc~gettable getTable program~demo3->proc~gettable Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables rowsL colsL nMachL rowsD colsD nMachD i j C81 LMat DMat Source Code demo3 Variables Type Attributes Name Initial integer, parameter :: rowsL = 25 integer, parameter :: colsL = 4 integer, parameter :: nMachL = 3 integer, parameter :: rowsD = 25 integer, parameter :: colsD = 4 integer, parameter :: nMachD = 3 integer :: i integer :: j type(C81_class) :: C81 real, dimension(rowsL,colsL) :: LMat real, dimension(rowsD,colsD) :: DMat Source Code program demo3 use libC81 implicit none integer , parameter :: rowsL = 25 integer , parameter :: colsL = 4 integer , parameter :: nMachL = 3 integer , parameter :: rowsD = 25 integer , parameter :: colsD = 4 integer , parameter :: nMachD = 3 integer :: i , j type ( C81_class ) :: C81 real , dimension ( rowsL , colsL ) :: LMat real , dimension ( rowsD , colsD ) :: DMat ! Read airfoil lift data from CSV file LMat = getTable ( 'Samples/lift.csv' , rowsL , colsL ) ! Read airfoil drag data from CSV file DMat = getTable ( 'Samples/drag.csv' , rowsD , colsD ) ! Allocate arrays allocate ( C81 % MaL ( nMachL )) allocate ( C81 % MaD ( nMachD )) allocate ( C81 % MaM ( nMachL )) allocate ( C81 % AL ( rowsL - 1 )) allocate ( C81 % AD ( rowsD - 1 )) allocate ( C81 % AM ( rowsL - 1 )) allocate ( C81 % CL ( rowsL - 1 , nMachL )) allocate ( C81 % CD ( rowsD - 1 , nMachD )) allocate ( C81 % CM ( rowsL - 1 , nMachL )) ! Specify airfoil name C81 % airfoilName = 'GA(W)-2' ! Copy values from read array to variables C81 % MaL = LMat ( 1 , 2 :) C81 % MaD = DMat ( 1 , 2 :) C81 % MaM = C81 % MaL C81 % AL = LMat ( 2 :, 1 ) C81 % AD = DMat ( 2 :, 1 ) C81 % AM = C81 % AL do j = 2 , colsL do i = 2 , rowsL C81 % CL ( i - 1 , j - 1 ) = LMat ( i , j ) enddo enddo do j = 2 , colsD do i = 2 , rowsD C81 % CD ( i - 1 , j - 1 ) = DMat ( i , j ) enddo enddo C81 % CM = C81 % CL ! Write airfoil data to C81 file call c81 % writefile ( 'Samples/output.C81' ) end program demo3"},{"tags":"","title":"demo2 – C81 Interface","loc":"program/demo2.html","text":"Uses libC81 program~~demo2~~UsesGraph program~demo2 demo2 module~libc81 libC81 program~demo2->module~libc81 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~demo2~~CallsGraph program~demo2 demo2 proc~gettable getTable program~demo2->proc~gettable Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables rows cols nMach i j C81 A Source Code demo2 Variables Type Attributes Name Initial integer, parameter :: rows = 19 integer, parameter :: cols = 4 integer, parameter :: nMach = cols-1 integer :: i integer :: j type(C81_class) :: C81 real, dimension(rows,cols) :: A Source Code program demo2 use libC81 implicit none integer , parameter :: rows = 19 integer , parameter :: cols = 4 integer , parameter :: nMach = cols - 1 integer :: i , j type ( C81_class ) :: C81 real , dimension ( rows , cols ) :: A ! Read airfoil data from CSV file A = getTable ( 'Samples/multiMain.csv' , rows , cols ) ! Allocate arrays allocate ( C81 % MaL ( nMach )) allocate ( C81 % MaD ( nMach )) allocate ( C81 % MaM ( nMach )) allocate ( C81 % AL ( rows - 1 )) allocate ( C81 % AD ( rows - 1 )) allocate ( C81 % AM ( rows - 1 )) allocate ( C81 % CL ( rows - 1 , nMach )) allocate ( C81 % CD ( rows - 1 , nMach )) allocate ( C81 % CM ( rows - 1 , nMach )) ! Specify airfoil name C81 % airfoilName = 'multiMain' ! Copy values from read array to variables C81 % MaL = A ( 1 , 2 :) C81 % MaD = C81 % MaL C81 % MaM = C81 % MaL C81 % AL = A ( 2 :, 1 ) C81 % AD = C81 % AL C81 % AM = C81 % AL do j = 2 , cols do i = 2 , rows C81 % CL ( i - 1 , j - 1 ) = A ( i , j ) enddo enddo C81 % CD = C81 % CL C81 % CM = C81 % CL ! Write airfoil data to C81 file call c81 % writefile ( 'Samples/multiMain.C81' ) end program demo2"},{"tags":"","title":"demo1 – C81 Interface","loc":"program/demo1.html","text":"Uses libC81 program~~demo1~~UsesGraph program~demo1 demo1 module~libc81 libC81 program~demo1->module~libc81 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~demo1~~CallsGraph program~demo1 demo1 proc~gettable getTable program~demo1->proc~gettable proc~getinterval getInterval program~demo1->proc~getinterval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables rows cols C81 A i j Source Code demo1 Variables Type Attributes Name Initial integer, parameter :: rows = 4 integer, parameter :: cols = 4 type(C81_class) :: C81 real, dimension(4,4) :: A integer :: i integer :: j Source Code program demo1 use libC81 implicit none integer , parameter :: rows = 4 integer , parameter :: cols = 4 type ( C81_class ) :: C81 real , dimension ( 4 , 4 ) :: A integer :: i , j ! Read airfoil data from C81 file call C81 % readfile ( 'Samples/sample1.C81' ) print * , 'Airfoil data read SUCCESSFUL' print * ! Write airfoil data to C81 file call C81 % writefile ( 'Samples/sampleOutput.C81' ) print * , 'Airfoil data write SUCCESSFUL' print * ! Read tabular data from csv file to Fortran array ! Works similar to dlmread() from Matlab ! Useful for creating arrays from airfoil data in CSV format A = getTable ( 'Samples/sample1.csv' , rows , cols ) print * , 'Tabular data read SUCCESSFUL' print * do i = 1 , size ( A , 1 ) print * ,( A ( i , j ), j = 1 , size ( A , 2 )) enddo print * ! Find left and right indices from 1-d sorted array in which ! a queried value lies print * , A ( 1 ,:) print * , getInterval ( A ( 1 ,:), 0.15 ) print * , 'Binary search SUCCESSFUL' ! Return 2-d interpolated value from 2-d array print * print * , C81 % getCL ( - 1 4.5 , 0.425 ) print * , '2-d interpolation SUCCESSFUL' end program demo1"},{"tags":"","title":"README – C81 Interface","loc":"page//index.html","text":"This set of programs was created owing to the lack of available open-source interfaces to the C81 airfoil table format. This package contains Fortran subroutines to read, write and create from scratch C81 formatted airfoil performance files. C81 File A C81 airfoil performance table is a text file that lists coefficients of lift, drag, and pitching moment of an airfoil as functions of angle of attack for a range of Mach numbers. This file is often used as input to reduced-order flight dynamics simulation programs for estimation of aerodynamic forces and moments. The data obtained using this format is typically used to implement lookup tables with linear interpolation. The angles of attack are generally specified from -180 to +180 degrees and the Mach numbers over a desired range. Lift, drag and moment coefficients are each tabulated one below the other as two-dimensional tables in a fixed spacing format. Data for these tables are usually obtained from CFD or experiments. The C81 format provided below was obtained from Stanko, J. D. in his 2017 thesis titled Automated Design and Evaluation of Airfoils for Rotorcraft Applications . C81 File Format Read/Write Format\n--------------------------------------       ------------------\nAIRFOIL_NAME        ML,NL,MD,ND,MM,NM          A30,6I2,6I2 \n       M(1)     ...   ...    M(ML)             7X,9F7.0 \nAL(1)  CL(1,1)  ...   ...    CL(1,NL)          10F7.0/(7X,9F7.0) \n.      .                     .                 .\n.      .                     .                 .\n.      .                     .                 .\nAL(NL) CL(NL,1) ...   ...    CL(NL,ML)         10F7.0/(7X,9F7.0) \n       M(1)     ...   ...    M(MD)             7X,9F7.0 \nAD(1) CD(1,1)   ...   ...    CD(1,ND)          10F7.0/(7X,9F7.0) \n.      .                     .                 .\n.      .                     .                 .\n.      .                     .                 .\nAD(ND) CD(ND,1) ...   ...    CD(ND,MD)         10F7.0/(7X,9F7.0) \n       M(1)     ...   ...    M(MM)             7X,9F7.0 \nAM(1)  CM(1,1)  ...   ...    CM(1,NM)          10F7.0/(7X,9F7.0) \n.      .                     .                 .\n.      .                     .                 .\n.      .                     .                 .\nAM(NM) CM(NM,1) ...   ...    CM(NM,MM)         10F7.0/(7X,9F7.0) \n\nAL = Lift coefficient angles of attack \nAD = Drag coefficient angles of attack \nAM = Pitching moment coefficient angles of attack \nML = Number of lift coefficient Machs \nNL = Number of lift coefficient alphas \nMD = Number of drag coefficient Machs Contents of the repository This repository contains a module file named libC81.f90 having the subroutines and functions for interfacing with C81 files. It also contains a few demo fortran programs that exemplify the usage of the module. Detailed information is available in the sections of this documentation corresponding to each file."}]}